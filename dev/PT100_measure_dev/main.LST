C51 COMPILER V9.02   MAIN                                                                  06/21/2018 04:58:26 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil4for51\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "STC15F2K60S2.h"
   2          #include "intrins.h"
   3          
   4          #define ADC_POWER   0x80    //ADCµçÔ´¿ØÖÆÎ»
   5          #define ADC_FLAG    0x10    //ADCÍê³É±êÖ¾Î»
   6          #define ADC_START   0x08    //ADCÆô¶¯¿ØÖÆÎ»
   7          #define ADC_SPEED0  0x00    //ADC×ª»»ËÙ¶È£¬Ò»´Î×ª»»ÐèÒª540¸öÊ±ÖÓ
   8          #define ADC_SPEED1  0x20    //ADC×ª»»ËÙ¶È£¬Ò»´Î×ª»»ÐèÒª360¸öÊ±ÖÓ
   9          #define ADC_SPEED2  0x40    //ADC×ª»»ËÙ¶È£¬Ò»´Î×ª»»ÐèÒª180¸öÊ±ÖÓ
  10          #define ADC_SPEED3  0x60    //ADC×ª»»ËÙ¶È£¬Ò»´Î×ª»»ÐèÒª90¸öÊ±ÖÓ
  11            
  12          /*ÊýÂë¹Ü¶ÎÂë±í  µÍµçÆ½ÓÐÐ§*///0    1    2        3       4         5    6       7        8        9             A        B    E   F     -    Ãð
  13          unsigned char code Table[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0x88,0x83,0x86,0x8E,0xBF,0xF
             -F};// ÊýÂë¹Ü×ª»»×Ö±í 0-9,A-F GHPU ,-,Ãð
  14          unsigned char code Table1[]={'0','1','2','3','4','5','6','7','8','9','-'};//×Ö·û´®×ª»»×Ö±í0-9,-,Ãð
  15          unsigned char Sendtemp[6]={' ',' ',' ',' ',' ',' '};    //´®¿Ú´«ÊäÊý×é
  16          unsigned char Showtemp[4]={0,0,0,0};    //ÊýÂë¹ÜÏÔÊ¾ÏÔÊ¾Êý×é
  17          unsigned char MAXMINtemp[3]={0,0,0};    //×î´óÖµ×îÐ¡ÖµÉè¶¨ÔÝ´æÊý×é
  18          
  19          char loca_count =0;      //
  20          char signal = 0;         //·ûºÅ±äÁ¿
  21          float maxmum = 40;       //ÎÂ¶È×î´óÖµ
  22          float minmum = 20;       //ÎÂ¶È×îÐ¡Öµ
  23          int maxmum1 = 0;         //×î´óÖµÔÝ´æ
  24          int minmum1 = 0;     //×îÐ¡ÖµÔÝ´æ
  25          char flag1 = 0;           
  26          char error = 0;      //´íÎó×´Ì¬¼ì²â
  27          
  28          float  VCC_measure  = 0;    //µçÑ¹²âÁ¿Öµ±äÁ¿
  29          float temp_result = 0;          //ÎÂ¶È²âÁ¿Öµ±äÁ¿
  30          int voltage_2_5v_ad = 0;
  31          unsigned char Ledcount = 0;    //ÊýÂë¹ÜÏÔÊ¾¼ÆÊý
  32          unsigned char keycount = 0;    //Þô¼üÏû¶¶¶¨Ê±20ms¼ÆÊý
  33          unsigned char keystatus = 0;   //Þô¼üÞôÏÂ×´Ì¬±äÁ¿ 
  34          unsigned char key = 0;             // Þô¼üÑ­»·±äÁ¿
  35          unsigned char key_final = 0;   //Þô¼üÌ§Æðºó×îÖÕÖ´ÐÐ±äÁ¿
  36          char mood = 0;                 //ÏµÍ³¹¤×÷Ä£Ê½    0²âÎÂ   1µçÑ¹
  37          char sleep_flag = 0;           //ÐÝÃß±êÖ¾
  38          char sleep_flag1 = 0;
  39          char turn_start =1;                        //
  40          char PT100_error_flag = 0;
  41          char alarm_mood = 0;               //ÎÂ¶ÈÉÏÏÂÏÞ±¨¾¯Ä£Ê½Ñ¡Ôñ
  42          
  43          float code NTC[146][2]={
  44          {-40,340.9281},{-39,318.8772},{-38,298.3978},{-37,279.3683},{-36,261.6769},{-35,245.2212},{-34,229.9072},{
             --33,215.6488},{-32,202.3666},{-31,189.9878},
  45          {-30,178.4456},{-29,167.6783},{-28,157.6292},{-27,148.246},{-26,139.4807},{-25,131.2888},{-24,123.6294},{-
             -23,116.4648},{-22,109.76},{-21,103.4829},
  46          {-20,97.6037},{-19,92.0947},{-18,86.9305},{-17,82.0877},{-16,77.5442},{-15,73.2798},{-14,69.2759},{-13,65.
             -5149},{-12,61.9809},{-11,58.6587},
  47          {-10,55.5345},{-9,52.5954},{-8,49.8294},{-7,47.2253},{-6,44.7727},{-5,42.462},{-4,40.2841},{-3,38.2307},{-
             -2,36.294},{-1,34.4668},{0,32.7421},
  48          {1,31.1138},{2,29.5759},{3,28.1229},{4,26.7496},{5,25.4513},{6,24.2234},{7,23.0618},{8,21.9625},{9,20.9218
             -},{10,19.9364},
  49          {11,19.0029},{12,18.1184},{13,17.28},{14,16.4852},{15,15.7313},{16,15.0161},{17,14.3375},{18,13.6932},{19,
C51 COMPILER V9.02   MAIN                                                                  06/21/2018 04:58:26 PAGE 2   

             -13.0815},{20,12.5005},
  50          {21,11.9485},{22,11.4239},{23,10.9252},{24,10.451},{25,10},{26,9.5709},{27,9.1626},{28,8.7738},{29,8.4037}
             -,{30,8.0512},
  51          {31,7.7154},{32,7.3954},{33,7.0904},{34,6.7996},{35,6.5223},{36,6.2577},{37,6.0053},{38,5.7645},{39,5.5345
             -},{40,5.315},
  52          {41,5.1053},{42,4.905},{43,4.7136},{44,4.5307},{45,4.3558},{46,4.1887},{47,4.0287},{48,3.8758},{49,3.7294}
             -,{50,3.5893},
  53          {51,3.4553},{52,3.3269},{53,3.2039},{54,3.0862},{55,2.9733},{56,2.8652},{57,2.7616},{58,2.6622},{59,2.5669
             -},{60,2.4755},
  54          {61,2.3879},{62,2.3038},{63,2.2231},{64,2.1456},{65,2.0712},{66,1.9998},{67,1.9312},{68,1.8653},{69,1.8019
             -},{70,1.7411},
  55          {71,1.6826},{72,1.6264},{73,1.5723},{74,1.5203},{75,1.4703},{76,1.4222},{77,1.3759},{78,1.3313},{79,1.2884
             -},{80,1.2471},
  56          {81,1.2073},{82,1.169},{83,1.1321},{84,1.0965},{85,1.0623},{86,1.0293},{87,0.9974},{88,0.9667},{89,0.9372}
             -,{90,0.9086},
  57          {91,0.8811},{92,0.8545},{93,0.8289},{94,0.8042},{95,0.7803},{96,0.7572},{97,0.735},{98,0.7135},{99,0.6927}
             -,{100,0.6727},
  58          {101,0.6533},{102,0.6346},{103,0.6165},{104,0.599},{105,0.5821}
  59          };//NTC±í
  60          float code PT100[14][2]={
  61          //{25,0.620},{30,0.89},{35,1.18},{40,1.46},{45,1.75},{50,2.01},{55,2.37},{60,2.66},{65,2.95},{70,3.335},{7
             -5,3.60},{80,3.90}
  62          {25,0.83},{30,1.10},{35,1.38},{40,1.65},{45,1.946},{50,2.248},{55,2.548},{60,2.84},{61,2.90},{62,2.95},
  63          {63,3.02},{64,3.09},{65,3.20},{70,3.50}
  64          };//NTC±í
  65          sbit LED1 = P4^2;
  66          sbit LED2 = P4^4;
  67          sbit KEY3 = P3^4;
  68          sbit KEY2 = P3^5;
  69          sbit KEY1 = P3^6;
  70          sbit TURN1 = P2^7;
  71          sbit TURN2 = P2^6;
  72          sbit TURN3 = P2^5;
  73          sbit TURN4 = P2^4;
  74          sbit FAN =      P3^2;                    
  75          sbit BUZZ = P3^3;
  76          
  77          /******************************
  78          º¯ÊýËµÃ÷£ºÑÓÊ±º¯Êý  1-65535ºÁÃë
  79          Èë¿Ú²ÎÊý£ºms=ÑÓÊ±ºÁÃëÊý
  80          ³ö¿Ú²ÎÊý£ºÎÞ
  81          ******************************/
  82          void Delay_MS(unsigned int ms)
  83          {
  84   1          unsigned char i, j;
  85   1          _nop_();
  86   1          while(ms--)
  87   1          {
  88   2              i = 6;  j = 210;
  89   2              while (--i)
  90   2              while (--j);
  91   2          }
  92   1      }
  93           
  94          /******************************
  95          º¯ÊýËµÃ÷£º³õÊ¼»¯ADC¼Ä´æÆ÷£¬ÉèÖÃP1.6ÎªADCÊäÈë¹¦ÄÜ
  96          Èë¿Ú²ÎÊý£ºÎÞ
  97          ³ö¿Ú²ÎÊý£ºÎÞ
  98          ******************************/
  99          void Init_ADC(void)
 100          {
 101   1          P1M1 = 0xFF;
C51 COMPILER V9.02   MAIN                                                                  06/21/2018 04:58:26 PAGE 3   

 102   1              P1M0 = 0x00;
 103   1          P1ASF = 0x40;       //´ò¿ªP1.6¿ÚµÄADC¹¦ÄÜ
 104   1          //P1 &= 0xBF;         //ÉèÖÃP1.6¿ÚÊä³öµÍµçÆ½È·±£ÄÜ²É¼¯µ½Íâ²¿µçÆ½ÐÅºÅ
 105   1              //P1 = 0x37;
 106   1          ADC_RES = 0;        //ÇåµôADC×ª»»½á¹û¼Ä´æÆ÷
 107   1          ADC_CONTR = ADC_POWER | ADC_SPEED3; //Ê¹ÄÜA/D¹©µç£¬ÉèÖÃ×ª»»ËÙ¶È90T
 108   1      }
 109          
 110          /******************************
 111          º¯ÊýËµÃ÷£º²éÑ¯·½Ê½¶ÁÈ¡ADC×ª»»½á¹û
 112          Èë¿Ú²ÎÊý£ºchannel  ADC²ÉÑùÍ¨µÀ
 113          ³ö¿Ú²ÎÊý£ºresult   ADC_RES ADC×ª»»½á¹û
 114          ******************************/
 115          unsigned int Get_AD(unsigned char channel)
 116          {
 117   1          unsigned int result;
 118   1          ADC_RES = 0;    
 119   1          ADC_RESL= 0;//ÇåµôADC×ª»»½á¹û¼Ä´æÆ÷
 120   1          ADC_CONTR =ADC_POWER|ADC_SPEED0|ADC_START|channel;//ÅäÖÃADC£¬ÉèÖÃ×ª»»Í¨µÀ£¬Æô¶¯×ª»»
 121   1          _nop_();    _nop_();
 122   1          _nop_();    _nop_();            //µÈ´ýÉèÖÃADC_POWERÍê±Ï
 123   1          while (!(ADC_CONTR & ADC_FLAG));//¶ÁÈ¡×ª»»Íê±Ï±êÖ¾Î»ADC_FLAG
 124   1          ADC_CONTR &= ~ADC_FLAG;         //Çå³ýADC_FLAG±êÖ¾Î»
 125   1          result = ADC_RES<<2|ADC_RESL;   //¶ÁÈ¡10Î»×ª»»½á¹û±£´æµ½result
 126   1          return result;                  //·µ»ØADC×ª»»½á¹û10Î»
 127   1      }
 128          
 129          /******************************
 130          º¯ÊýËµÃ÷£ºµçÑ¹Öµ²âÁ¿º¯Êý
 131          Èë¿Ú²ÎÊý£ºÎÞ
 132          ³ö¿Ú²ÎÊý£ºvoltage ¼ÆËãºóµÃµ½µÄµçÑ¹Öµ
 133          ******************************/
 134          float Voltage_Measure(void)
 135          {        int   i = 0,j = 0;
 136   1           float voltage = 0;
 137   1               int voltage_AD_avg = 0;          //AD²ÉÑùÆ½¾ùÖµ
 138   1               unsigned int voltage_std_AD = 0;
 139   1               for(j=0;j<10;j++)                               //10´ÎÇóÆ½¾ù ²ÉÑù¼ä¸ô1ms
 140   1                {
 141   2                        voltage_std_AD = Get_AD(7);
 142   2                        Delay_MS(1);                                                     //²ÉÑù¼ä¸ô1ms
 143   2                        voltage_AD_avg += voltage_std_AD;
 144   2                }
 145   1               voltage_AD_avg = voltage_AD_avg/10;    //  ³ý10ÇóÆ½¾ù
 146   1               //voltage = (1024/(float)voltage_std_AD )*2.5;
 147   1               voltage = (1067/(float)voltage_AD_avg )*2.5;
 148   1               return voltage; 
 149   1      }
 150          
 151          float Voltage_Measure2_5v_ad(void)
 152          {        int   i = 0,j = 0;
 153   1           float voltage = 0;
 154   1               int voltage_AD_avg = 0;          //AD²ÉÑùÆ½¾ùÖµ
 155   1               unsigned int voltage_std_AD = 0;
 156   1               for(j=0;j<10;j++)                               //10´ÎÇóÆ½¾ù ²ÉÑù¼ä¸ô1ms
 157   1                {
 158   2                        voltage_std_AD = Get_AD(7);
 159   2                        Delay_MS(1);                                                     //²ÉÑù¼ä¸ô1ms
 160   2                        voltage_AD_avg += voltage_std_AD;
 161   2                }
 162   1               voltage_AD_avg = voltage_AD_avg/10;    //  ³ý10ÇóÆ½¾ù
 163   1               //voltage = (1024/(float)voltage_std_AD )*2.5;
C51 COMPILER V9.02   MAIN                                                                  06/21/2018 04:58:26 PAGE 4   

 164   1               //voltage = (1067/(float)voltage_AD_avg )*2.5;
 165   1               return voltage_AD_avg; 
 166   1      }
 167          
 168          /******************************
 169          º¯ÊýËµÃ÷£ºÎÂ¶ÈÖµ²âÁ¿º¯Êý
 170          Èë¿Ú²ÎÊý£ºÎÞ
 171          ³ö¿Ú²ÎÊý£ºtemperature ¼ÆËãºóµÃµ½µÄÎÂ¶ÈÖµ
 172          ******************************/
 173          float Temp_Measure()
 174          {         int   i = 0,j = 0;
 175   1            unsigned int voltage_AD = 0;        //±¾´Î²ÉÑùADÖµ
 176   1                long int voltage_AD_avg = 0;    //AD²ÉÑùÆ½¾ùÖµ
 177   1                float voltage = 0;              //¸ù¾ÝadÇó³öµÄµçÑ¹Öµ ²»ÀûÓÃµçÔ´µçÑ¹µÄÇó·¨
 178   1                float resistance = 0;           //¸ù¾ÝµçÑ¹Ëã³öµÄ´«¸ÐÆ÷×èÖµ
 179   1                float temperature = 0;                  //ÎÂ¶ÈÖµ
 180   1      
 181   1                for(j=0;j<10;j++)                              //10´ÎÇóÆ½¾ù ²ÉÑù¼ä¸ô1ms
 182   1                {
 183   2                        voltage_AD = Get_AD(6);
 184   2                        Delay_MS(1);                                                     //²ÉÑù¼ä¸ô1ms
 185   2                        voltage_AD_avg += voltage_AD;
 186   2                }
 187   1                
 188   1                voltage_AD_avg = voltage_AD_avg/10;    //  ³ý10ÇóÆ½¾ù 
 189   1                if (voltage_AD_avg <5 )                                //´«¸ÐÆ÷Î´Á¬½ÓÅÐ¶Ï  Èç¹ûÃ»µçÑ¹ÔòÃ»ÓÐÁ¬½Ó
 190   1                {error = 1;}
 191   1                else
 192   1                {error = 0;}
 193   1                resistance = 10*(1024 - (float)voltage_AD_avg)/(float)voltage_AD_avg;    //¼ÆËãµç×èÖµ ¸ù¾ÝÂúµçÑ¹adÎª102
             -4
 194   1                for(i=0; i<145; i++)                                                                                                     //ÂÖÑ¯·¨²é±í
 195   1                {
 196   2                   if((resistance<=NTC[i][1]) && (resistance>NTC[i+1][1]) )     //|| (resistance>=NTC[i][1])
 197   2                         {
 198   3                                      temperature = NTC[i][0] + (NTC[i][1]-resistance)/(NTC[i][1]-NTC[i+1][1]);break;   //ÏßÐÔ²åÖµ·¨
 199   3                         }
 200   2                       else continue;
 201   2                }               
 202   1                return temperature;
 203   1      }
 204          
 205          /******************************
 206          º¯ÊýËµÃ÷£ºÎÂ¶ÈÖµ²âÁ¿º¯Êý    Ê¹ÓÃPT100£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£
             -¡£¡£¡£¡£¡£¡£¡£¡£¡£¡
 207          Èë¿Ú²ÎÊý£ºÎÞ
 208          ³ö¿Ú²ÎÊý£ºtemperature ¼ÆËãºóµÃµ½µÄÎÂ¶ÈÖµ
 209          ******************************/
 210          float Temp_Measure_PT100(int voltage_std_ad)
 211          {         int   i = 0,j = 0;
 212   1            unsigned int voltage_AD = 0;        //±¾´Î²ÉÑùADÖµ
 213   1                long int voltage_AD_avg = 0;    //AD²ÉÑùÆ½¾ùÖµ
 214   1                float voltage = 0;              //¸ù¾ÝadÇó³öµÄµçÑ¹Öµ ²»ÀûÓÃµçÔ´µçÑ¹µÄÇó·¨
 215   1                float temperature = 0;                  //ÎÂ¶ÈÖµ
 216   1                long float resistance = 0;
 217   1                for(j=0;j<10;j++)                              //10´ÎÇóÆ½¾ù ²ÉÑù¼ä¸ô1ms
 218   1                {
 219   2                        voltage_AD = Get_AD(3);    //PT100Á¬½ÓÍ¨µÀ2
 220   2                        Delay_MS(1);                                                     //²ÉÑù¼ä¸ô1ms
 221   2                        voltage_AD_avg += voltage_AD;
 222   2                }
 223   1                
C51 COMPILER V9.02   MAIN                                                                  06/21/2018 04:58:26 PAGE 5   

 224   1                voltage_AD_avg = voltage_AD_avg/10;    //  ³ý10ÇóÆ½¾ù 
 225   1                if (voltage_AD_avg <5)                                 //´«¸ÐÆ÷Î´Á¬½ÓÅÐ¶Ï  Èç¹ûÃ»µçÑ¹ÔòÃ»ÓÐÁ¬½Ó
 226   1                {error = 1;}
 227   1                else
 228   1                {error = 0;}
 229   1                voltage = ((float)voltage_AD_avg/(float)voltage_std_ad)*2.5;
 230   1      //        resistance = (6200*(long float)voltage_AD_avg+10057565.6)/(121177.812-(long float)voltage_AD_avg);      
             - //¼ÆËãµç×èÖµ ¸ù¾ÝÂúµçÑ¹adÎª1024
 231   1                PT100_error_flag = 1;
 232   1                for(i=0; i<13; i++)                                                                                                      //ÂÖÑ¯·¨²é±í    n-1
 233   1                {
 234   2                   if(( voltage >= PT100[i][1]) && ( voltage < PT100[i+1][1]) )         //|| (resistance>=NTC[i][1])
 235   2                         {
 236   3                                      temperature = PT100[i][0] + (voltage - PT100[i][1])/(PT100[i+1][1]-PT100[i][1])*(PT100[i+1][0]-PT10
             -0[i][0]);          //ÏßÐÔ²åÖµ·¨
 237   3                                      PT100_error_flag = 0;
 238   3                                      break;
 239   3                         }
 240   2                       else continue;
 241   2                }               
 242   1                return temperature;
 243   1      //        return voltage_AD_avg;
 244   1      
 245   1      //        return voltage;
 246   1      }
 247          
 248          /******************************
 249          º¯ÊýËµÃ÷£ºÊý×ª»»Îª4Î»ÊýÂë¹ÜÏÔÊ¾Âë
 250          Èë¿Ú²ÎÊý£ºdat Ðè×ª»¯µÄÊý×Ö
 251          ³ö¿Ú²ÎÊý£ºÎÞ ²Ù×÷¶ÔÏóÎªShowtemp[4]
 252          ******************************/
 253          void LED_Translate(float dat)
 254          {
 255   1          int data1 = 0;
 256   1              
 257   1              if ((dat<10)&&(dat>-10))
 258   1              {
 259   2                      data1 = (int)(dat*100);
 260   2                              if(dat >= 0)    
 261   2                              {Showtemp[0] = 0xFF;}                      //ÊýÂë¹ÜµÚ1Î»ÏÔÊ¾ ·ûºÅÎ»
 262   2                              if(dat < 0)     
 263   2                              {Showtemp[0] = 0xBF;
 264   3                              data1 = 0-data1;}
 265   2                      Showtemp[1] =  Table[(data1/100)]&0x7F;       //¸öÎ»ÊýÏÔÊ¾  ¼ÓÐ¡Êýµã                                            
 266   2                      Showtemp[2] =  Table[data1%100/10];         //Ð¡ÊýµãºóÒ»Î»ÏÔÊ¾          
 267   2                      Showtemp[3] =  Table[data1%10];                   //Ð¡ÊýµãºóÁ½Î»ÏÔÊ¾
 268   2          }
 269   1              else if ((dat<100)&&(dat>-100))
 270   1              {
 271   2                      data1 = (int)(dat*10);
 272   2                              if(dat >= 0)    
 273   2                              {Showtemp[0] = 0xFF;}                           //ÊýÂë¹ÜµÚ1Î»ÏÔÊ¾       ·ûºÅÎ»
 274   2                              if(dat < 0)     
 275   2                              {Showtemp[0] = 0xBF;
 276   3                              data1 = 0-data1;}
 277   2                      Showtemp[1] =  Table[data1/100];                 //Ê®Î»ÊýÏÔÊ¾                                   
 278   2                      Showtemp[2] =  Table[data1%100/10]&0x7F;     //¸öÎ»ÊýÏÔÊ¾  ¼ÓÐ¡Êýµã          
 279   2                      Showtemp[3] =  Table[data1%10];                      //Ð¡ÊýµãºóÒ»Î»ÏÔÊ¾
 280   2          }
 281   1              else if ((dat>=100)&&(dat<1000))
 282   1              {
 283   2                       data1 = (int)(dat*10);
C51 COMPILER V9.02   MAIN                                                                  06/21/2018 04:58:26 PAGE 6   

 284   2                       Showtemp[0] =  Table[data1/1000];                //°ÙÎ»ÊýÏÔÊ¾
 285   2                       Showtemp[1] =  Table[data1%1000/100];            //Ê®Î»ÊýÏÔÊ¾                                  
 286   2                       Showtemp[2] =  Table[data1%100/10]&0x7F;     //¸öÎ»ÊýÏÔÊ¾  ¼ÓÐ¡Êýµã          
 287   2                       Showtemp[3] =  Table[data1%10];                      //Ð¡ÊýµãºóÒ»Î»ÏÔÊ¾
 288   2              }
 289   1              else if (dat>=1000)
 290   1              {
 291   2                       Showtemp[0] =  Table[(int)dat/1000];      //Ç§Î»ÊýÏÔÊ¾
 292   2                       Showtemp[1] =  Table[(int)dat%1000/100];   //°ÙÎ»ÊýÏÔÊ¾                                        
 293   2                       Showtemp[2] =  Table[(int)dat%100/10];     //Ê®Î»ÊýÏÔÊ¾
 294   2                       Showtemp[3] =  Table[(int)dat%10];                     //¸ö
 295   2              }                                               
 296   1      }
 297          /******************************
 298          º¯ÊýËµÃ÷£ºÊý×ª»»Îª6Î»×Ö·û´® ×îºóÒ»Î»Îª¿Õ¸ñ
 299          Èë¿Ú²ÎÊý£ºdat Ðè×ª»¯µÄÊý×Ö
 300          ³ö¿Ú²ÎÊý£ºÎÞ ²Ù×÷¶ÔÏóÎªSendtemp[6]
 301          ******************************/
 302          void STR_Translate(float dat)
 303          {
 304   1          int data1 = 0;
 305   1              Sendtemp[0] =  ' ';           //¸öÎ»ÊýÏÔÊ¾  ¼ÓÐ¡Êýµã                                            
 306   1              Sendtemp[1] =  ' ';         //Ð¡ÊýµãºóÒ»Î»ÏÔÊ¾          
 307   1              Sendtemp[2] =  ' ';               //Ð¡ÊýµãºóÁ½Î»ÏÔÊ¾
 308   1              Sendtemp[3] =  ' ';           //¸öÎ»ÊýÏÔÊ¾  ¼ÓÐ¡Êýµã                                            
 309   1              Sendtemp[4] =  ' ';         //Ð¡ÊýµãºóÒ»Î»ÏÔÊ¾
 310   1              Sendtemp[5] =  ' ';         //Ð¡ÊýµãºóÒ»Î»ÏÔÊ¾          
 311   1              if ((dat<10)&&(dat>-10))
 312   1              {
 313   2                      data1 = (int)(dat*100);
 314   2                              if(dat >= 0)    
 315   2                              {Sendtemp[0] = ' ';}                       //ÊýÂë¹ÜµÚ1Î»ÏÔÊ¾
 316   2                              if(dat < 0)     
 317   2                              {Sendtemp[0] = '-';
 318   3                              data1 = 0-data1;}
 319   2                      Sendtemp[1] =  Table1[(data1/100)];           //¸öÎ»ÊýÏÔÊ¾  ¼ÓÐ¡Êýµã
 320   2                      Sendtemp[2] =  '.';                                             
 321   2                      Sendtemp[3] =  Table1[data1%100/10];         //Ð¡ÊýµãºóÒ»Î»ÏÔÊ¾          
 322   2                      Sendtemp[4] =  Table1[data1%10];                  //Ð¡ÊýµãºóÁ½Î»ÏÔÊ¾
 323   2          }
 324   1              else if ((dat<100)&&(dat>-100))
 325   1              {
 326   2                      data1 = (int)(dat*10);
 327   2                              if(dat >= 0)    
 328   2                              {Sendtemp[0] = ' ';}                       //ÊýÂë¹ÜµÚ1Î»ÏÔÊ¾
 329   2                              if(dat < 0)     
 330   2                              {Sendtemp[0] = '-';
 331   3                              data1 = 0-data1;}
 332   2                      Sendtemp[1] =  Table1[data1/100];                 //Ê®Î»ÊýÏÔÊ¾                                  
 333   2                      Sendtemp[2] =  Table1[data1%100/10];
 334   2                      Sendtemp[3] =  '.';                       //¸öÎ»ÊýÏÔÊ¾  ¼ÓÐ¡Êýµã          
 335   2                      Sendtemp[4] =  Table1[data1%10];                  //Ð¡ÊýµãºóÒ»Î»ÏÔÊ¾
 336   2          }
 337   1              else if ((dat>=100)&&(dat<1000))
 338   1              {
 339   2                       data1 = (int)(dat*10);
 340   2                       Sendtemp[0] =  Table1[data1/1000];               //baiÎ»ÊýÏÔÊ¾
 341   2                       Sendtemp[1] =  Table1[data1/100];                //Ê®Î»ÊýÏÔÊ¾                                  
 342   2                       Sendtemp[2] =  Table1[data1%100/10];     //¸öÎ»ÊýÏÔÊ¾  ¼ÓÐ¡Êýµã
 343   2                       Sendtemp[3] =  '.';         
 344   2                       Sendtemp[4] =  Table1[data1%10];                 //Ð¡ÊýµãºóÒ»Î»ÏÔÊ¾
 345   2              }
C51 COMPILER V9.02   MAIN                                                                  06/21/2018 04:58:26 PAGE 7   

 346   1              else if (dat>=1000)
 347   1              {
 348   2                       Sendtemp[0] =  Table1[(int)dat/1000];     //baiÎ»ÊýÏÔÊ¾
 349   2                       Sendtemp[1] =  Table1[(int)dat%1000/100];   //Ê®Î»ÊýÏÔÊ¾                                       
 350   2                       Sendtemp[2] =  Table1[(int)dat%100/10];     //¸öÎ»ÊýÏÔÊ¾
 351   2                       Sendtemp[3] =  Table1[(int)dat%10];
 352   2              }                                               
 353   1      }
 354          
 355          /******************************
 356          º¯ÊýËµÃ÷£ºÊýÂë¹ÜÈ«Ãð ÎÞÐè½øÈëÖÐ¶ÏÖ´ÐÐ È«²¿ ËÄ¸öÎ» À­¸ß
 357          Èë¿Ú²ÎÊý£ºÎÞ
 358          ³ö¿Ú²ÎÊý£ºÎÞ 
 359          ******************************/
 360          void LED_Clean(void)             //LEDµÆÈ«Ãðº¯Êý
 361          {       int ii = 0;
 362   1              Showtemp[0] = 0xFF;     
 363   1              Showtemp[1] = 0xFF; 
 364   1              Showtemp[2] = 0xFF; 
 365   1              Showtemp[3] = 0xFF;
 366   1              for(ii=0; ii<4; ii++)
 367   1              {
 368   2                  P2 = 0x0F;               //¹Ø±ÕËùÓÐÊýÂë¹ÜÑ¡Í¨
 369   2              P0 = Showtemp[ii];       //ËÍ¶ÎÂë µÍµçÆ½ÓÐÐ§
 370   2              P2 = ~(0x01<<ii);    }   //Ñ¡ÔñÎ»Ñ¡
 371   1      }
 372          /******************************
 373          º¯ÊýËµÃ÷£ºÞô¼üÉ¨Ãèº¯Êý ÖÐ¶ÏÖ´ÐÐ 
 374          Èë¿Ú²ÎÊý£ºÎÞ   È«¾Ö±äÁ¿   keystatus  keycount  key_final
 375          ³ö¿Ú²ÎÊý£ºÎÞ 
 376          ******************************/
 377          void key_scan(void)
 378          {
 379   1              if (keystatus == 0)                      //Þô¼üÞôÏÂ
 380   1                      {                   
 381   2                              if (KEY1 == 0)
 382   2                              keystatus =1;
 383   2                              if (KEY2 == 0)
 384   2                              keystatus =2;
 385   2                              if (KEY3 == 0)
 386   2                              keystatus =3; 
 387   2                      }
 388   1              else
 389   1              {           
 390   2                      keycount++;
 391   2                      if(keycount==50)                        //Ïû¶¶¼ì²â
 392   2                      {
 393   3                         keycount = 0;
 394   3                         if(keystatus == 1)
 395   3                                {if (KEY1 == 0)
 396   4                                        key = 1;}
 397   3                         if(keystatus == 2)
 398   3                                {if (KEY2 == 0)
 399   4                                        key = 2;}
 400   3                         if(keystatus == 3)
 401   3                                {if (KEY3 == 0)
 402   4                                        key = 3;}
 403   3                         keystatus =0;
 404   3                      }
 405   2                      
 406   2              }
 407   1         if(key == 1)                                         //Þô¼üÌ§ÆðÈ·ÈÏ  key_finalÖÃÎ»´ú±íÒ»´ÎÞô¼üÎïÀíÒâÒåÍê³É
C51 COMPILER V9.02   MAIN                                                                  06/21/2018 04:58:26 PAGE 8   

 408   1                {if (KEY1 == 1)
 409   2                        {key_final = 1;key = 0;}}
 410   1         if(key == 2)
 411   1                {if (KEY2 == 1)
 412   2                        {key_final = 2;key = 0;}}
 413   1         if(key == 3)
 414   1                {if (KEY3 == 1)
 415   2                        {key_final = 3;key = 0;}}
 416   1      }
 417          
 418          /******************************
 419          º¯ÊýËµÃ÷£º¶¨Ê±Æ÷0³õÊ¼»¯  16Î»¶¨Ê±Æ÷×Ô¶¯ÖØ×°ÔØÄ£Ê½
 420          Èë¿Ú²ÎÊý£ºÎÞ   
 421          ³ö¿Ú²ÎÊý£ºÎÞ 
 422          ******************************/
 423          void Timer0Init(void)           //500Î¢Ãë@11.0592MHz
 424          {
 425   1              AUXR |= 0x80;           //¶¨Ê±Æ÷Ê±ÖÓ1TÄ£Ê½
 426   1              TMOD &= 0xF0;           //ÉèÖÃ¶¨Ê±Æ÷Ä£Ê½
 427   1      
 428   1              TL0 = 0x66;                 //ÉèÖÃ¶¨Ê±³õÖµ
 429   1              TH0 = 0xEA;                 //ÉèÖÃ¶¨Ê±³õÖµ
 430   1              TF0 = 0;                //Çå³ýTF0±êÖ¾
 431   1              TR0 = 1;                    //¶¨Ê±Æ÷0¿ªÊ¼¼ÆÊ±
 432   1      }
 433          
 434          /******************************
 435          º¯ÊýËµÃ÷£ºÍâ²¿ÖÐ¶Ï2ÖÐ¶Ï·þÎñº¯Êý  ÐÝÃß±êÖ¾ÖÃÎ»ºÍÈ¡Ïû
 436          Èë¿Ú²ÎÊý£ºÎÞ   
 437          ³ö¿Ú²ÎÊý£ºÎÞ   ÐÞ¸ÄÈ«¾Ö±äÁ¿sleep_flag
 438          ******************************/
 439          void input2_ISR (void) interrupt 10                   //Íâ²¿ÖÐ¶Ï2
 440          {
 441   1           Delay_MS(25);
 442   1               if (KEY1 == 0)           
 443   1               {
 444   2               if(sleep_flag == 0)
 445   2                      {sleep_flag = 1;}
 446   2               else if(sleep_flag == 1)
 447   2                  sleep_flag = 0;
 448   2               } 
 449   1      }
 450          
 451          /******************************
 452          º¯ÊýËµÃ÷£º¶¨Ê±Æ÷0ÖÐ¶Ï·þÎñº¯Êý  ÊýÂë¹ÜÉ¨Ãè  Þô¼üÉ¨Ãè
 453          Èë¿Ú²ÎÊý£ºÎÞ   
 454          ³ö¿Ú²ÎÊý£ºÎÞ   ÐÞ¸ÄÈ«¾Ö±äÁ¿sleep_flag
 455          ******************************/
 456          //Time0É¨ÃèLEDÏÔÊ¾Çý¶¯£¬¼ÆÊ±,500us
 457          void time0(void) interrupt 1
 458          {
 459   1          if(4==++Ledcount)              //ÊýÂë¹ÜÉ¨Ãè
 460   1          {Ledcount=0;
 461   2              }
 462   1          P2 = 0x0F;                 //¹Ø±ÕËùÓÐÊýÂë¹ÜÑ¡Í¨
 463   1          P0 = Showtemp[Ledcount];       //ËÍ¶ÎÂë µÍµçÆ½ÓÐÐ§
 464   1          P2 = ~(0x01<<Ledcount);       //Ñ¡ÔñÎ»Ñ¡
 465   1      
 466   1          key_scan();                            //Þô¼üÉ¨Ãè
 467   1      }
 468          /******************************
 469          º¯ÊýËµÃ÷£º¹¤×÷Ä£Ê½Ñ¡Ôñ 0²âÎÂ¶È 1²âµçÑ¹
C51 COMPILER V9.02   MAIN                                                                  06/21/2018 04:58:26 PAGE 9   

 470          Èë¿Ú²ÎÊý£ºÎÞ   
 471          ³ö¿Ú²ÎÊý£ºÎÞ  
 472          ******************************/
 473          void mood_choose_work(void)
 474          {
 475   1              if(mood == 0)
 476   1              {
 477   2      
 478   2                      temp_result = Temp_Measure();   //²âÎÂ¶È
 479   2                      LED_Translate(temp_result);             //×ª»»³öÊýÂë¹ÜÏÔÊ¾Öµ
 480   2                      STR_Translate(temp_result);             //×ª»»³ö´®¿Ú´«ÊäÖµ
 481   2                      
 482   2                      if(alarm_mood == 1)                                                                //±¨¾¯Ä£Ê½
 483   2                      {
 484   3                              if((temp_result>maxmum)||(temp_result<minmum))
 485   3                              {
 486   4                                      if(temp_result>maxmum)
 487   4                                              {LED2 = ~LED2;            //³¬×î´óÖµÂÌµÆÉÁ      ºìµÆ³£Ãð
 488   5                                              LED1 = 1;}
 489   4                                      if(temp_result<minmum)
 490   4                                          {LED1 = ~LED1;                 //µÍÓÚ×îÐ¡ÖµºìµÆÉÁ ÂÌµÆ³¤Ãð
 491   5                                              LED2 = 1;}
 492   4                              }
 493   3                              else                                              //±¨¾¯Ä£Ê½Õý³£ÏÂ È·±£ÂÌµÆÁÁºìµÆÃð
 494   3                              {           
 495   4                              LED1 = 1;
 496   4                              LED2 = 0;}                              
 497   3                      }
 498   2                      else if(mood != 2)                                                                                        //·Ç±¨¾¯Ä£Ê½ È·±£ÂÌµÆÁÁºìµÆÃð
 499   2                      {
 500   3                              LED1 = 1;
 501   3                              LED2 = 0;
 502   3                      }
 503   2              }               
 504   1               if(mood == 1)
 505   1              {
 506   2                  LED1 = 0;
 507   2                      LED2 = 1;                                 //Ä£Ê½1ºìµÆÁÁ
 508   2                      VCC_measure = Voltage_Measure();        //²âµçÑ¹
 509   2                      LED_Translate(VCC_measure);                     //×ª»»³öÊýÂë¹ÜÏÔÊ¾Öµ
 510   2                  STR_Translate(VCC_measure);                 //×ª»»³ö´®¿Ú´«ÊäÖµ
 511   2              }
 512   1              if(mood == 2)
 513   1              {
 514   2                  LED1 = 1;
 515   2                      LED2 = 1;                                 //Ä£Ê½2µÆÈ«Ãð
 516   2                      voltage_2_5v_ad = Voltage_Measure2_5v_ad();//²â2.5v±ê×¼µçÑ¹
 517   2                      temp_result = Temp_Measure_PT100(voltage_2_5v_ad);      //²âÎÂ¶È
 518   2                      LED_Translate(temp_result);                     //×ª»»³öÊýÂë¹ÜÏÔÊ¾Öµ
 519   2                  STR_Translate(temp_result);                 //×ª»»³ö´®¿Ú´«ÊäÖµ
 520   2              }
 521   1               
 522   1      }
 523          
 524          /******************************
 525          º¯ÊýËµÃ÷£ºÐÝÃß×´Ì¬¼ì²â Ö÷Ñ­»·µ÷ÓÃ 
 526          Èë¿Ú²ÎÊý£ºÎÞ   
 527          ³ö¿Ú²ÎÊý£ºÎÞ  
 528          ******************************/
 529          void sleep_check(void)
 530          {
 531   1          if((sleep_flag == 1)||(sleep_flag1 == 1))    //sleep_flag Þô¼ü½øÈë   sleep_flag1 ²¦Âë¿ª¹Ø½øÈë
C51 COMPILER V9.02   MAIN                                                                  06/21/2018 04:58:26 PAGE 10  

 532   1              {
 533   2                      if(sleep_flag1 == 1)
 534   2                      {turn_start = 0;sleep_flag1 = 0;}               
 535   2                      LED_Clean();       //¹Ø±ÕÊýÂë¹Ü
 536   2                      LED2 = 1;LED1 = 0;Delay_MS(200);LED1 = 1;Delay_MS(200);LED1 = 0;Delay_MS(200);LED1 = 1;            //ÐÝÃßÇ°ºìµÆ
             -ÉÁË¸        
 537   2                      PCON = 0x02;                                       //½øÈëÐÝÃß  ³ÌÐòÍ£ÔÚ´Ë´¦
 538   2                      _nop_();_nop_();_nop_();                   //»½ÐÑºóÖ´ÐÐµÄ¿ÕÖ¸Áî
 539   2                      LED2 = 0;Delay_MS(200);LED2 = 1;Delay_MS(200);LED2 = 0;Delay_MS(200);LED2 = 1;Delay_MS(200);LED2 = 0;  /
             -/»½ÐÑºóÂÌµÆÉÁË¸
 540   2              }
 541   1      }
 542          
 543          /******************************
 544          º¯ÊýËµÃ÷£ºÞô¼ü×´Ì¬¼ì²â Ö÷Ñ­»·µ÷ÓÃ       Þô¼üÕý³£¹¤×÷ÞôÏÂÖ´ÐÐ³ÌÐòÔÚ´Ë´¦
 545          Èë¿Ú²ÎÊý£ºÎÞ   
 546          ³ö¿Ú²ÎÊý£ºÎÞ  
 547          ******************************/
 548          void key_check(void)
 549          {
 550   1              if(key_final == 1)   // Þô¼ü1ÞôÏÂÖ´ÐÐ³ÌÐòÎ»ÖÃ
 551   1              {}
 552   1              if(key_final == 2)       // Þô¼ü2ÞôÏÂÖ´ÐÐ³ÌÐòÎ»ÖÃ
 553   1              {if(mood < 2) 
 554   2                    {mood ++;}             
 555   2               else{mood = 0;}
 556   2               }
 557   1              if(key_final == 3)       // Þô¼ü3ÞôÏÂÖ´ÐÐ³ÌÐòÎ»ÖÃ
 558   1              {}
 559   1              key_final = 0;
 560   1      }
 561          /******************************
 562          º¯ÊýËµÃ÷£ºÞô¼üÉèÖÃ²ÎÊý ´¦Àí³ÌÐò ÉèÖÃ×î´óÖµ×îÐ¡Öµ
 563          Èë¿Ú²ÎÊý£ºÎÞ   
 564          ³ö¿Ú²ÎÊý£ºÎÞ    Ó°ÏìÈ«¾Ö±äÁ¿ MAXMINtemp[]          loca_count   signal
 565          ******************************/
 566          void key_check_setnum(void)
 567          {       
 568   1          if(loca_count<3)     //¸öÎ»Ê®Î» Ð¡ÊýµãºóÒ»Î» ´¦Àí
 569   1              {
 570   2                      if(key_final == 1)   // Þô¼ü1ÞôÏÂÖ´ÐÐ³ÌÐòÎ»ÖÃ  µ±Ç°Î»¼Ó1
 571   2                      {if(MAXMINtemp[loca_count]<9)
 572   3                                      MAXMINtemp[loca_count]++;
 573   3                              else
 574   3                                      MAXMINtemp[loca_count] = 0;}
 575   2                      if(key_final == 2)       // Þô¼ü2ÞôÏÂÖ´ÐÐ³ÌÐòÎ»ÖÃ  µ±Ç°Î»¼õ1
 576   2                      {
 577   3                        if(MAXMINtemp[loca_count]>0)
 578   3                                      MAXMINtemp[loca_count]--;
 579   3                              else
 580   3                                      MAXMINtemp[loca_count] = 9;
 581   3                      }
 582   2              }
 583   1      
 584   1              if(loca_count == 3)          //·ûºÅÎ»´¦Àí
 585   1              {
 586   2                      if(key_final == 1)   // Þô¼ü1ÞôÏÂÖ´ÐÐ³ÌÐòÎ»ÖÃ  È¡·´
 587   2                      {if(signal == 1) 
 588   3                    signal = 0;
 589   3               else if(signal == 0)  
 590   3                    signal = 1;}
 591   2                      if(key_final == 2)   // Þô¼ü2ÞôÏÂÖ´ÐÐ³ÌÐòÎ»ÖÃ  È¡·´
C51 COMPILER V9.02   MAIN                                                                  06/21/2018 04:58:26 PAGE 11  

 592   2                      {if(signal == 1) 
 593   3                    signal = 0;
 594   3               else if(signal == 0)  
 595   3                    signal = 1;}
 596   2              }
 597   1              if(key_final == 3)           // Þô¼ü3ÞôÏÂÖ´ÐÐ³ÌÐòÎ»ÖÃ
 598   1              {
 599   2                      if(loca_count<3)
 600   2                              loca_count++;
 601   2                      else
 602   2                              loca_count = 0;
 603   2              }
 604   1              key_final = 0;
 605   1      }
 606          /******************************
 607          º¯ÊýËµÃ÷£ºÞô¼üÉèÖÃ²ÎÊý ´¦Àí³ÌÐò ÉèÖÃ×î´óÖµ×îÐ¡Öµ
 608          Èë¿Ú²ÎÊý£ºÎÞ   È«¾Ö±äÁ¿ MAXMINtemp[]       loca_count   signal
 609          ³ö¿Ú²ÎÊý£º numresult ×î´óÖµ×îÐ¡Öµ¼ÆËãÖµ
 610          ******************************/
 611          float set_num_calculate()
 612          {
 613   1              float numresult = 0;
 614   1              numresult = 10*(float)MAXMINtemp[0] + (float)MAXMINtemp[1] + 0.1*(float)MAXMINtemp[2];
 615   1              if (signal == 1)
 616   1              numresult = 0 - numresult;
 617   1              return numresult;
 618   1      }
 619          
 620          /******************************
 621          º¯ÊýËµÃ÷£º²¦Âë¿ª¹Ø×´Ì¬¼ì²â Ö÷Ñ­»·µ÷ÓÃ   ²¦Âë¿ª¹ØÕý³£¹¤×÷ÞôÏÂÖ´ÐÐ³ÌÐòÔÚ´Ë´¦
 622          Èë¿Ú²ÎÊý£ºÎÞ   
 623          ³ö¿Ú²ÎÊý£ºÎÞ  
 624          ******************************/
 625          void turn_check(void)
 626          {
 627   1              while((TURN1 == 0)&& (TURN2 != 0))         //²¦Âë1Îªon Óë2»¥Ëø
 628   1              {       LED1 = 0;
 629   2                      LED2 = 0;
 630   2                      INT_CLKO = 0x00; //½ûÓÃÍâ²¿ÖÐ¶Ï2
 631   2                      if(flag1==0)
 632   2                      {
 633   3                              flag1 = 1;              
 634   3                              if ((maxmum<100)&&(maxmum>-100))          //ÕâÒ»²¿·Ö·ÀÖ¹ÉèÖÃÍêmin ÉèÖÃmaxÊ± ÏÔÊ¾µÄÉèÖÃ³õÊ¼ÖµÊÇminµÄ
 635   3                              {
 636   4                                      maxmum1 = (int)(maxmum*10);
 637   4                                              if(maxmum >= 0) 
 638   4                                              {signal = 0;}                      
 639   4                                              if(maxmum < 0)  
 640   4                                              {signal = 1;
 641   5                                              maxmum1 = 0-maxmum1;}
 642   4                                      MAXMINtemp[0] =  maxmum1/100;                                           
 643   4                                      MAXMINtemp[1] =  maxmum1%100/10;              
 644   4                                      MAXMINtemp[2] =  maxmum1%10;              
 645   4                          }
 646   3                      }
 647   2                      key_check_setnum();
 648   2                      maxmum = set_num_calculate();
 649   2                      LED_Translate(maxmum);
 650   2                      WDT_CONTR =0x3E;                        //Î¹¿´ÃÅ¹·
 651   2              }
 652   1              INT_CLKO |= 0x10; //ÔÊÐíÍâ²¿ÖÐ¶Ï2
 653   1      
C51 COMPILER V9.02   MAIN                                                                  06/21/2018 04:58:26 PAGE 12  

 654   1              while((TURN2 == 0)&& (TURN1 != 0))         //²¦Âë2Îªon Óë1»¥Ëø
 655   1              {
 656   2                  LED1 = 0;
 657   2                      LED2 = 0;
 658   2                      INT_CLKO = 0x00; //½ûÓÃÍâ²¿ÖÐ¶Ï2
 659   2                      if(flag1==0)
 660   2                  {
 661   3                              flag1 = 1;                      
 662   3                              if ((minmum<100)&&(minmum>-100))     //ÕâÒ»²¿·Ö·ÀÖ¹ÉèÖÃÍêmax ÉèÖÃminÊ± ÏÔÊ¾µÄÉèÖÃ³õÊ¼ÖµÊÇmaxµÄ
 663   3                              {
 664   4                                      minmum1 = (int)(minmum*10);
 665   4                                      if(minmum >= 0) 
 666   4                                      {signal = 0;}                      //ÊýÂë¹ÜµÚ1Î»ÏÔÊ¾
 667   4                                      if(minmum < 0)  
 668   4                                      {signal = 1;
 669   5                                      minmum1 = 0-minmum1;}
 670   4                                      MAXMINtemp[0] =  minmum1/100;                                           
 671   4                                      MAXMINtemp[1] =  minmum1%100/10;              
 672   4                                      MAXMINtemp[2] =  minmum1%10;              
 673   4                          }
 674   3                      }
 675   2                      key_check_setnum();                              
 676   2                      minmum = set_num_calculate();    //      ¸³Öµ
 677   2                      LED_Translate(minmum);                   //ÏÔÊ¾×îÐ¡Öµ
 678   2                      WDT_CONTR =0x3E;                         //Î¹¿´ÃÅ¹·
 679   2              }
 680   1              INT_CLKO |= 0x10; //ÔÊÐíÍâ²¿ÖÐ¶Ï2
 681   1              flag1 = 0;
 682   1                if(TURN3 == 0)                                           //²¦Âë3Ñ¡ÔñÊÇ·ñ½øÈëÉÏÏÂÏÞ±¨¾¯±¨¾¯
 683   1                {
 684   2                              alarm_mood = 1;
 685   2                }
 686   1                else
 687   1                {
 688   2                        alarm_mood = 0;
 689   2                        LED2 = 0;
 690   2                }
 691   1      //     if(TURN4 == 0)                                           //²¦Âë4½øÈëÐÝÃßÄ£Ê½
 692   1      //      {
 693   1      //              Delay_MS(50);
 694   1      //          if(TURN4 == 0)
 695   1      //              {
 696   1      //                      if((sleep_flag1 == 0)&&(turn_start == 1))
 697   1      //                      {sleep_flag1 = 1;}
 698   1      //              }
 699   1      //      }
 700   1      //      else if (turn_start == 0)
 701   1      //      {turn_start = 1;}
 702   1      }
 703          /******************************
 704          º¯ÊýËµÃ÷£º´®¿Ú1³õÊ¼»¯³ÌÐò 9600bps
 705          Èë¿Ú²ÎÊý£ºÎÞ   
 706          ³ö¿Ú²ÎÊý£ºÎÞ  
 707          ******************************/
 708          void UartInit(void)             //9600bps@11.0592MHz
 709          {
 710   1              SCON = 0x50;            //8Î»Êý¾Ý,¿É±ä²¨ÌØÂÊ
 711   1              AUXR |= 0x40;           //¶¨Ê±Æ÷1Ê±ÖÓÎªFosc,¼´1T
 712   1              AUXR &= 0xFE;           //´®¿Ú1Ñ¡Ôñ¶¨Ê±Æ÷1Îª²¨ÌØÂÊ·¢ÉúÆ÷
 713   1              TMOD &= 0x0F;           //Éè¶¨¶¨Ê±Æ÷1Îª16Î»×Ô¶¯ÖØ×°·½Ê½
 714   1              TL1 = 0xE0;             //Éè¶¨¶¨Ê±³õÖµ
 715   1              TH1 = 0xFE;             //Éè¶¨¶¨Ê±³õÖµ
C51 COMPILER V9.02   MAIN                                                                  06/21/2018 04:58:26 PAGE 13  

 716   1              ET1 = 0;                //½ûÖ¹¶¨Ê±Æ÷1ÖÐ¶Ï
 717   1              TR1 = 1;                //Æô¶¯¶¨Ê±Æ÷1
 718   1      }
 719          /******************************
 720          º¯ÊýËµÃ÷£º´®¿Ú1ÖÐ¶Ï·þÎñ³ÌÐò ·¢ËÍÊý¾Ýµ½´®¿Ú
 721          Èë¿Ú²ÎÊý£ºÎÞ    ·¢ËÍÈ«¾Ö±äÁ¿ Sendtemp[] Ò»´Îº¯Êý·¢È«²¿Êý¾Ý
 722          ³ö¿Ú²ÎÊý£ºÎÞ  
 723          ******************************/
 724          void UART1_ISR() interrupt 4
 725          {   
 726   1              if (RI)                                  //Èç¹ûÊÕµ½ÇëÇóÐÅÏ¢
 727   1              {   
 728   2                  SBUF =Sendtemp[0] ;   //·¢ËÍÕû¸öÊý×é    
 729   2                      Delay_MS(2);                                            
 730   2                      SBUF =Sendtemp[1] ;            
 731   2                      Delay_MS(2);       
 732   2                      SBUF =Sendtemp[2] ;     
 733   2                      Delay_MS(2);
 734   2                      SBUF =Sendtemp[3];            
 735   2                      Delay_MS(2);                                            
 736   2                      SBUF =Sendtemp[4];        
 737   2                      Delay_MS(2);
 738   2                      SBUF =Sendtemp[5];       
 739   2                      Delay_MS(2);       
 740   2               
 741   2                 RI = 0;
 742   2              }
 743   1              else
 744   1                 TI = 0;                               //Çå·¢ËÍ±êÖ¾
 745   1      }
 746          void main(void)
 747          {  
 748   1         WDT_CONTR =0x3E;
 749   1         Init_ADC();       //³õÊ¼»¯ADC
 750   1         UartInit();
 751   1         ES = 1; 
 752   1         Timer0Init();     //ÉèÖÃT0ÓÃ×÷ÊýÂë¹ÜÏÔÊ¾¶¨Ê±500usÉ¨Ãè£¬ÖÐ¶ÏÄ£Ê½
 753   1         ET0=1;            //ÔÊÐíT0¶¨Ê±ÖÐ¶Ï
 754   1         INT_CLKO |= 0x10; //ÔÊÐíÍâ²¿ÖÐ¶Ï2
 755   1         EA=1;                         //ÖÐ¶Ï×ÜÊ¹ÄÜ
 756   1         Ledcount=0;      //LEDÉ¨ÃèÏÔÊ¾¼ÆÊýÓÃ
 757   1         P0M0=0xff;       //ÍÆÍìÊä³öÇý¶¯¹²Òõ¼«ÊýÂë¹Ü  
 758   1         KEY1 = 1;KEY2 = 1;KEY3 = 1;                   //À­¸ßËùÓÐÞô¼ü  µÍµçÆ½ÓÐÐ§
 759   1         TURN1 = 1;TURN2 = 1;TURN3 = 1;TURN4 = 1;                //À­¸ßËùÓÐ²¦Âë¿ª¹Ø µÍµçÆ½ÓÐÐ§
 760   1                  
 761   1         Showtemp[0]=Table[1];
 762   1         Showtemp[1]=Table[0];
 763   1         Showtemp[2]=Table[2];
 764   1         Showtemp[3]=Table[7];
 765   1      
 766   1         Delay_MS(2000);
 767   1         
 768   1         
 769   1         while(1)
 770   1         {    
 771   2                      turn_check();                      //²¦Âë¿ª¹Ø¼ì²â
 772   2                      sleep_check();                     //ÐÝÃßÄ£Ê½¼ì²â
 773   2              key_check();                       //Þô¼üÊÇ·ñÞôÏÂ¼ì²â
 774   2                      mood_choose_work();                //¹¤×÷Ä£Ê½Ñ¡Ôñ²¢work £¨²âÁ¿£©
 775   2                      if(maxmum<minmum)                  //Á½ÖÖerror
 776   2                      error = 2;
 777   2                      if(error == 1)
C51 COMPILER V9.02   MAIN                                                                  06/21/2018 04:58:26 PAGE 14  

 778   2                      {
 779   3                              Showtemp[0]=0xff;
 780   3                              Showtemp[1]=0xff;
 781   3                              Showtemp[2]=0x86;   //E
 782   3                              Showtemp[3]=Table[1];   //ÏÔÊ¾E1
 783   3                      }
 784   2                      if (error == 2)
 785   2                      {
 786   3                              Showtemp[0]=0xff;
 787   3                              Showtemp[1]=0xff;
 788   3                              Showtemp[2]=0x86; //E
 789   3                              Showtemp[3]=Table[2];   //ÏÔÊ¾E2
 790   3                      }
 791   2                      if(PT100_error_flag == 1)
 792   2                      {
 793   3                              Showtemp[0]=0xff;
 794   3                              Showtemp[1]=0xff;
 795   3                              Showtemp[2]=0x86; //E
 796   3                              Showtemp[3]=Table[3];   //ÏÔÊ¾E3
 797   3                              PT100_error_flag = 0;
 798   3                      }
 799   2                      Delay_MS(200);                     //ÑÓÊ±200ms
 800   2                      WDT_CONTR =0x3E;                   //Î¹¿´ÃÅ¹·
 801   2         }
 802   1      }                


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4560    ----
   CONSTANT SIZE    =   1307    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     50      74
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
